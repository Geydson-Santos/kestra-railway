# --- Database (PostgreSQL on Railway) ---
datasources:
  postgres:
    # Railway Postgres URL; set as env var KESTRA_PG_URL (see .env.example)
    url: ${KESTRA_PG_URL}
    driverClassName: org.postgresql.Driver
    username: ${KESTRA_PG_USER}
    password: ${KESTRA_PG_PASSWORD}

# --- Core Kestra bits ---
kestra:
  # Use Postgres for queue & repository (prod recommendation)
  queue:
    type: postgres
  repository:
    type: postgres

  # Internal storage for inputs/outputs/artifacts.
  # For Railway Volumes, mount e.g. /data and point basePath there.
  storage:
    type: local
    local:
      basePath: /data/storage

  # UI & API URL (optional but nice for links in the UI)
  url: ${PUBLIC_URL:`http://localhost:8080/`}

  # Basic auth is required on recent versions; set via env
  server:
    basicAuth:
      # enabled flag is ignored on newer versionsâ€”just set credentials
      username: ${KESTRA_USERNAME:`[email protected]`}
      password: ${KESTRA_PASSWORD:`change-me-please`}

  # Default task runner: PROCESS (Railway doesn't provide Docker-in-Docker)
  tasks:
    defaults:
      io.kestra.plugin.scripts.python.Commands:
        taskRunner:
          type: io.kestra.plugin.core.runner.Process
      io.kestra.plugin.scripts.shell.Commands:
        taskRunner:
          type: io.kestra.plugin.core.runner.Process

# --- Monitoring / health endpoints (Prometheus, health, etc.) ---
endpoints:
  all:
    port: 8081

# --- Namespaces / flows folder on container ---
kestra:
  # Micronaut config supports env placeholders; keeping flows on /app/flows
  # Flows can also be created via UI/API; this just seeds an example.
  #
  # No extra config needed for scanning files when using the UI,
  # but you can also use Namespace Files in the UI if you prefer.
